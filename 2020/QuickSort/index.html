<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="WeiSch"><link rel="alternative" href="/atom.xml" title="SilentSpiral" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><title>Maybe QuickSort? - SilentSpiral</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">SilentSpiral</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/tags">标签</a></li><li class="head-nav__item"><a class="head-nav__link" href="/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2020-05-10T10:08:35.000Z">2020 - 05 - 10 18:08:35</time><h1 class="post__title"><a href="/2020/QuickSort/">Maybe QuickSort?</a></h1><div class="post__main echo"><h1 id="quick-selection">1.Quick Selection</h1>
<blockquote>
<p>目标：在n个数中找到前k大的数（或者第k大的数）</p>
</blockquote>
<p>如果使用小根堆来求解的话，时间复杂度是<span class="math inline">\(O(nlogk)\)</span></p>
<p>Quick Selection算法可以在平均<span class="math inline">\(O(n)\)</span>的时间复杂度内求解。(看起来很美好)</p>
<p>快速选择算法要求把全部数据装入内存，而建堆则不必一次性装入所有数据</p>
<p>所以堆可以处理海量数据的TopK问题</p>
<p>数据较少时，快速选择算法有理论上的优势</p>
<h2 id="原理">原理</h2>
<p>Quick Selection算法和Quick Sort算法是同由东尼霍尔提出，这两者之间有很大的相似之处——分治，即将问题的规模一次次的减小，直到求出最终解。</p>
<ol type="1">
<li>随机产生一个pivot</li>
<li>根据这个pivot，将小于其的数放左边，大于其的数放右边</li>
<li>更新第n大数的估计值的位置，选择其中一边，直到=n</li>
<li>重复2、3步骤</li>
</ol>
<p>快速排序算法使用了<strong>分治法</strong>，快速选择则使用了<strong>减治法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickSelection</span><span class="params">(<span class="keyword">int</span> *q, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123; <span class="comment">//应传入k-1</span></span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = Partition(q, low, high);</span><br><span class="line">        <span class="keyword">if</span> (mid&lt;k) &#123;</span><br><span class="line">            <span class="keyword">return</span> QuickSelection(q, k,mid+<span class="number">1</span>, high);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mid&gt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span> QuickSelection(q, k,low, mid<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> q[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于递归不再是快排一样的树形递归，此处也可以考虑把递归改成循环</p>
<p>反正开了O2以上的优化这里就是尾递归了，效率上区别不大但是<strong>参数太多</strong>显得不够优雅</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickSelection</span><span class="params">(<span class="keyword">int</span> *q, <span class="keyword">int</span> k, <span class="keyword">int</span> length)</span></span>&#123;<span class="comment">//应传入k-1, 或者函数内k--</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = len;</span><br><span class="line">    <span class="keyword">int</span> mid = partition(a,low,high);</span><br><span class="line">    <span class="keyword">while</span>(mid!=k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k&gt;mid) </span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        mid = partition(a,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q[mid]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（网上没找到代码自己写的）</p>
<h1 id="partition的三种实现">2.Partition的三种实现</h1>
<p>快速排序的双指针交换部分可以单独封装出来，提高可读性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> q = Partition(a, low, high);</span><br><span class="line">        QuickSort(a, low, q - <span class="number">1</span>);</span><br><span class="line">        QuickSort(a, q + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Partition函数有三种实现方式</p>
<h2 id="左右指针法">左右指针法</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;<span class="comment">//左右指针法    </span></span><br><span class="line">    <span class="keyword">int</span> key = right;<span class="comment">//利用key作为基准值的下标  </span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;<span class="comment">//左指针向右找第一个比key大的数  </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[key])  </span><br><span class="line">            ++left;    <span class="comment">//右指针向左扎找第一个比key的数  </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[key])  </span><br><span class="line">            --right;  </span><br><span class="line">        <span class="keyword">if</span> (a[left] != a[right]) <span class="comment">//交换左右指针所指的值  </span></span><br><span class="line">            swap(a[left],a[right]);    </span><br><span class="line">    &#125;  </span><br><span class="line">    swap(a[left],a[key]);  <span class="comment">//将key值放到正确位置上 </span></span><br><span class="line">    <span class="keyword">return</span> left;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="挖坑法">挖坑法</h2>
<blockquote>
<p>挖坑法的思想是类似于左右指针法的，思路是先将最右边的值保存下来，作为key值。这时候最右边的值被取出去，最右边就相当于有了一个坑，我们从左向右进行遍历，找到一个比key大的数就把它填到这个坑里，这时候就相当于坑在左边，我们有从右向左进行遍历找比key小的数，找到后再次填到坑里。依次类推，大致的思想和上面的解法其实是很相似的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;   <span class="comment">//挖坑法</span></span><br><span class="line">    <span class="keyword">int</span> i=left,j=right;</span><br><span class="line">    <span class="keyword">int</span> key = a[right];<span class="comment">//将区间最右侧数据基准值  </span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;      </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[left] &lt;= key)  <span class="comment">//左指针向右找比key大的数据  </span></span><br><span class="line">            ++left;    </span><br><span class="line">        a[j] = a[i];<span class="comment">//用找到的数据填坑  </span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[right] &gt;= key)   <span class="comment">//右指针想左找比key小的数据  </span></span><br><span class="line">            --right;    </span><br><span class="line">        a[i] = a[j];<span class="comment">//用找到的数据填坑   </span></span><br><span class="line">    &#125;  </span><br><span class="line">    a[j] = key;<span class="comment">//最后用key值填坑  </span></span><br><span class="line">    <span class="keyword">return</span> blank;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前后指针法">前后指针法</h2>
<blockquote>
<p>前后指针法的思路就是有两个指针，一个为cur，另一个为prev。开始的时候让cur指向left，让prev指向left的前一个位置。让cur向后找比key小的值，找到之后就让prev++，如果此时prev与cur不相等就让prev与cur进行交换。如果找不到比key小的值就一直让cur向后走，直到走到区间的最右边就停止，当cur走到边界的时候就让cur与prev进行交换。不断缩小边界，相同的方法进行遍历子区间。</p>
</blockquote>
<p><strong>这种实现方式可以对单链表进行快排</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = a[high];<span class="comment">//将输入数组的最后一个数作为主元，用它来对数组进行划分</span></span><br><span class="line">    <span class="keyword">int</span> i = low - <span class="number">1</span>;<span class="comment">//i是最后一个小于主元的数的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = low; j &lt; high; j++)&#123;<span class="comment">//遍历下标由low到high-1的数</span></span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; key)&#123;<span class="comment">//如果数小于主元的话就将i向前挪动一个位置，并且交换j和i所分别指向的数</span></span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            i++;</span><br><span class="line">            swap(a[i],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//经历上面的循环之后下标为从low到i（包括i）的数就均为小于x的数了，现在将主元和i+1位置上面的数进行交换</span></span><br><span class="line">    swap(a[++i],a[high]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="枢轴选取优化">3.枢轴选取优化</h1>
<h2 id="三数取中">三数取中</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMidIndex</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;    <span class="comment">//三数取中法  </span></span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span> (a[left] &lt; a[mid])&#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; a[right])&#123;  </span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (a[left] &lt; a[right])? right:left;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//a[left]&gt;=a[mid]   </span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; a[right])&#123;  </span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (a[left] &gt; a[right])? right:left;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随机选取">随机选取</h2>
<p>在调用partition前随机选取元素与枢轴位置的元素交换。</p>
<h1 id="区间三分">4.区间三分</h1>
<blockquote>
<p>数学家们发现，虽然快速排序已经很快了，但是在一种情况下存在可以优化的余地：</p>
<p>【数组中存在大量重复数据】</p>
<p>因为，“左右指针”分别找“比参照物大的元素”和“比参照物小的元素”，所以“等于参照物的元素”就原封不动的放在原地，在下一级迭代排序中继续参与排序。</p>
</blockquote>
<p><a href="https://blog.csdn.net/a8336675/article/details/51818743" target="_blank" rel="noopener">参考链接1</a></p>
<p><a href="https://www.cnblogs.com/nullzx/p/5880191.html" target="_blank" rel="noopener">参考链接2</a></p>
<p><a href="https://www.jianshu.com/p/4bf661f3cc04" target="_blank" rel="noopener">参考链接3</a>给出了简洁的版本：</p>
<blockquote>
<p>这里是和普通快速排序不一样的地方</p>
<p>这里维护几个索引</p>
<p>用i跟踪当前待比较的那一个元素</p>
<p>通过不断地递归将数组切分成三个部分</p>
<p>a[low…lt-1]：小于部分</p>
<p>a[lt…gt]：等于部分</p>
<p>a[gt+1, high]：大于部分</p>
<p>注意到partition部分有两个返回值，因此在c语言实现中不再把partition单独写成函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> lt = low, gt = high, i = lt + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> base = a[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt)&#123; <span class="comment">//对三种情况的处理</span></span><br><span class="line">           <span class="keyword">if</span> (a[i] &lt; base)</span><br><span class="line">                swap(a[lt++], a[i++]);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; base)</span><br><span class="line">                swap(a[gt--], a[i]);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        QuickSort(a, low, lt - <span class="number">1</span>);</span><br><span class="line">        QuickSort(a, gt + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并行化">5.并行化</h1>
<blockquote>
<p>从快速排序的基本思想可以得出以下结论：</p>
<p>通过一次排序分成2个待排序数组</p>
<p>通过二次排序分成4个待排序数组</p>
<p>……</p>
<p>通过n次排序分成2^n个待排序数组</p>
<p>假设CPU有N个Core(Intel CPU的核数通常是2的x次幂,AMD不一定)，那么log2N次排序后就可以进行并行化操作，将N个数组分别放到N个Core中进行计算，如下图所示</p>
</blockquote>
<p>假设处理器核足够多的情况下，并行化的快排可以达到O(n)的时间复杂度</p>
<p>裆燃了，存在并行化之后更快的算法：【双调排序】，并行前O(nlog<sup>2</sup>n)，并行后O(log<sup>2</sup>n)</p>
<h1 id="尾递归">6.尾递归？</h1>
<p>这段代码困扰我挺久的，原来它不是尾递归，只是通过修改快排的形式从而拉平递归树，期望减少栈深</p>
<blockquote>
<p>注意题目中说到了simulate tail recursion，而不是真正的tail recursion，是怎么实现的呢？如果一颗树的度变大了，那么它的高度自然就变小了。所以说为了达到尾递归的效果，可以在递归过程中，让递归函数尽量多的调用自己。</p>
<p>其实QUICKSORT’和QUICKSORT做的partition都是一样的。</p>
<p>QUICKSORT’先做一个Partition，找到q，然后对左边的子序列排序，接着并不是对右边的子序列排序，而是先将子序列进行一次Partition。本质上是一样的。 两者有什么区别呢？那就是递归的调用顺序 QUICKSORT的调用树是一个二叉树。一个QUICKSORT仅调用两次自己。而QUICKSORT’可以调用多次自己，这样它的调用树就不是二叉了。</p>
</blockquote>
<p><a href="https://blog.51cto.com/nxlhero/1112835" target="_blank" rel="noopener">参考链接</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> len,<span class="keyword">int</span> start,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">NULL</span>=p) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">int</span> index;</span><br><span class="line">   <span class="keyword">while</span>(start&lt;last)&#123;</span><br><span class="line">   	 index=Partition(p,len,start,last);</span><br><span class="line">	 QuickSort(p,len,start,index<span class="number">-1</span>);</span><br><span class="line">	 start=index+<span class="number">1</span>; </span><br><span class="line">   &#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="非递归实现">7.非递归实现</h1>
<blockquote>
<p>　　快速排序非递归化是怎么回事呢？快速排序相信大家都很熟悉，但是快速排序非递归化是怎么回事呢，下面就让小编带大家一起了解吧。</p>
<p>　　快速排序非递归化，其实就是<strong>自己手写一个栈来代替系统栈</strong>，大家可能会很惊讶快速排序怎么可以非递归化呢？但事实就是这样，小编也感到非常惊讶。</p>
<p>　　这就是关于快速排序非递归化的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortNotR</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	assert(<span class="built_in">array</span>);</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	s.push(left);</span><br><span class="line">	s.push(right); <span class="comment">//后入的right，所以要先拿right</span></span><br><span class="line">	<span class="keyword">while</span>(!s.empty)&#123; <span class="comment">//栈不为空</span></span><br><span class="line">		<span class="keyword">int</span> right = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		<span class="keyword">int</span> left = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> index = Partition(<span class="built_in">array</span>,left,right);</span><br><span class="line">		<span class="keyword">if</span>((index - <span class="number">1</span>) &gt; left)&#123;       <span class="comment">//左子序列</span></span><br><span class="line">			s.push(left);</span><br><span class="line">			s.push(index - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((index + <span class="number">1</span>) &lt; right)&#123;      <span class="comment">//右子序列</span></span><br><span class="line">			s.push(index + <span class="number">1</span>);</span><br><span class="line">			s.push(right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="why-quick">8.Why Quick？</h1>
<p><strong>实际开发中，为什么快速排序要比堆排序性能好？ </strong></p>
<h2 id="第一堆排序访问数据的方式没有快速排序友好">第一、堆排序访问数据的方式没有快速排序友好。</h2>
<p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶进行堆化，会依次访问数组下标是1，2，4，8的元素，而不像快速排序那样，局部顺序访问，所以，这样对CPU缓存是不友好的。</p>
<h2 id="第二对于同样的数据在排序过程中堆排序算法的数据交换次数要多于快速排序">第二、对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</h2>
<p>我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程是由两个基本操作组成的，比较和交换。快速排序交换的次数不会比逆序度多。</p>
<p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对选择顺序，导致数据有序度降低。比如对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p>
<h1 id="stdsort">9.std::sort</h1>
<blockquote>
<p>当我们划分的子区间很小的时候（一般情况下13为判断的标准），我们使用快速排序对于这些小区间进行排序的时候，如果我们还使用快速排序的话就会得不偿失。因为快速排序对子区间的划分就像二叉树一样，越到下面递归越深，那么还不如我们把这剩下的数取出来用其他的排序，这样的话也就提高快速排序的效率。</p>
</blockquote>
<p>具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GAP 13 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>  </span>&#123;<span class="comment">//小区间优化   </span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)&#123;    </span><br><span class="line">        <span class="keyword">if</span> (right - left &gt; GAP)&#123;    </span><br><span class="line">             <span class="keyword">int</span> div = Partition(a,left,right);    </span><br><span class="line">             QuickSort(a,left,div<span class="number">-1</span>);    </span><br><span class="line">             QuickSort(a,div+<span class="number">1</span>,right);    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">             InsertSort(a+left,right-left+<span class="number">1</span>);  <span class="comment">//这里的InsertSort用的是直接插入排序  </span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个视频可以看出快排在小区间优化前后的明显区别</p>
<iframe src="//player.bilibili.com/player.html?aid=62246751&amp;bvid=BV1Kt411M7CZ&amp;cid=108198126&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/算法/">算法</a></li><li class="post__tag__item"><a class="post__tag__link" href="/tags/排序/">排序</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png" title="微信"></div></section><div class="comments" id="v-container"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="/js/Valine.min.js"></script><script>new Valine({
  av: AV,
  el: '#v-container',
  app_id: 'IQzWzzCuitLQe0yLWG4VzRS6-gzGzoHsz',
  app_key: 'cs2RLiJ2qtHhAcFv0GnEELvz',
  avatar: 'retro',
  avatarForce: false,
  notify: false,
  verify: false,
  lang: 'zh-cn',
  placeholder: '来啊快活啊~',
  pageSize: 10,
  visitor: true,
  highlight: true,
  emoticon_url: '/img/alu',
  emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
});</script></div><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></main><footer class="foot"><div class="foot-copy">&copy; 2018 - 2020 WeiSch</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>